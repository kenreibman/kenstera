---
phase: 02-secure-api-route
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - lib/rate-limit/demo-call.ts
  - lib/recaptcha/verify.ts
  - app/api/demo-call/route.ts
autonomous: true
requirements: [SEC-01, SEC-02, SEC-03, SEC-04, SEC-05]
user_setup:
  - service: google-recaptcha-v3
    why: "reCAPTCHA v3 server-side verification requires a secret key"
    env_vars:
      - name: RECAPTCHA_SECRET_KEY
        source: "Google reCAPTCHA Admin Console -> Register site -> Copy Secret Key (use Google test key 6LeIxAcTAAAAAGG-vFI1TnRWxMZNFuojJ4WifJWe for local dev)"
    dashboard_config: []
  - service: upstash-redis
    why: "Rate limiting requires Upstash Redis credentials"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Create Redis Database -> REST API section -> UPSTASH_REDIS_REST_URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Create Redis Database -> REST API section -> UPSTASH_REDIS_REST_TOKEN"
    dashboard_config: []

must_haves:
  truths:
    - "A POST with a valid US phone and valid reCAPTCHA token triggers a Retell outbound call capped at 180 seconds"
    - "A POST with a non-US or invalid phone number returns 400 before any external API call"
    - "A forged or missing reCAPTCHA token returns 401 and no call is placed"
    - "A second POST from the same IP within 10 minutes returns 429"
    - "A second POST with the same phone number within 10 minutes returns 429"
    - "Consent timestamp and IP are logged to stdout before the call is placed"
    - "The Retell API key is never importable from client-side code"
  artifacts:
    - path: "lib/rate-limit/demo-call.ts"
      provides: "IP and phone number sliding-window rate limiters"
      exports: ["ipRatelimit", "phoneRatelimit"]
    - path: "lib/recaptcha/verify.ts"
      provides: "reCAPTCHA v3 server-side token verification"
      exports: ["verifyRecaptchaToken"]
    - path: "app/api/demo-call/route.ts"
      provides: "POST handler orchestrating validation pipeline"
      exports: ["POST"]
  key_links:
    - from: "app/api/demo-call/route.ts"
      to: "lib/recaptcha/verify.ts"
      via: "import verifyRecaptchaToken"
      pattern: "import.*verifyRecaptchaToken.*from.*@/lib/recaptcha/verify"
    - from: "app/api/demo-call/route.ts"
      to: "lib/rate-limit/demo-call.ts"
      via: "import ipRatelimit, phoneRatelimit"
      pattern: "import.*ipRatelimit.*phoneRatelimit.*from.*@/lib/rate-limit/demo-call"
    - from: "app/api/demo-call/route.ts"
      to: "lib/retell/client.ts"
      via: "import retell singleton"
      pattern: "import.*retell.*from.*@/lib/retell/client"
    - from: "app/api/demo-call/route.ts"
      to: "retell.call.createPhoneCall"
      via: "Retell SDK call with agent_override"
      pattern: "retell\\.call\\.createPhoneCall"
---

<objective>
Build the complete POST /api/demo-call route with all security controls: phone validation, reCAPTCHA v3 server verification, dual rate limiting (IP + phone), consent logging, and Retell outbound call creation with a 180-second duration cap.

Purpose: This route is the server-side backbone of the demo experience. Every security requirement (SEC-01 through SEC-05) is enforced here before any UI exists. The route must be testable via curl/Postman.

Output: Three new files (rate-limit helper, reCAPTCHA helper, route handler) and two new npm dependencies installed.
</objective>

<execution_context>
@C:/Users/DESKTOP/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/DESKTOP/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-secure-api-route/02-RESEARCH.md
@.planning/phases/01-provisioning/01-01-SUMMARY.md

# Existing patterns to follow:
@lib/retell/client.ts
@lib/db/leads.ts
@app/api/pi-intake-audit/capture/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create helper modules</name>
  <files>
    package.json
    package-lock.json
    lib/rate-limit/demo-call.ts
    lib/recaptcha/verify.ts
  </files>
  <action>
    **Step 1: Install new dependencies.**
    ```bash
    npm install @upstash/ratelimit libphonenumber-js
    ```

    **Step 2: Create `lib/rate-limit/demo-call.ts`** — Two Ratelimit instances for IP and phone.

    Follow the existing `lib/db/leads.ts` pattern for the Redis singleton (lazy initialization with getRedis()).

    ```typescript
    import { Ratelimit } from '@upstash/ratelimit'
    import { Redis } from '@upstash/redis'

    let redis: Redis | null = null

    function getRedis(): Redis {
      if (!redis) {
        const url = process.env.UPSTASH_REDIS_REST_URL
        const token = process.env.UPSTASH_REDIS_REST_TOKEN
        if (!url || !token) throw new Error('Missing UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN')
        redis = new Redis({ url, token })
      }
      return redis
    }

    // 1 request per IP per 10-minute sliding window (per user decision)
    export const ipRatelimit = new Ratelimit({
      redis: getRedis(),
      limiter: Ratelimit.slidingWindow(1, '10 m'),
      prefix: 'demo-call:ip',
    })

    // 1 request per phone number per 10-minute sliding window (per user decision)
    export const phoneRatelimit = new Ratelimit({
      redis: getRedis(),
      limiter: Ratelimit.slidingWindow(1, '10 m'),
      prefix: 'demo-call:phone',
    })
    ```

    Key details:
    - Use distinct `prefix` values to avoid key collision between IP and phone limiters
    - Module-level initialization is fine because @upstash/ratelimit is HTTP-based (no socket overhead)
    - The getRedis() lazy singleton matches `lib/db/leads.ts` pattern exactly

    **Step 3: Create `lib/recaptcha/verify.ts`** — Server-side reCAPTCHA v3 token verification.

    ```typescript
    interface RecaptchaResponse {
      success: boolean
      score: number
      action: string
      challenge_ts: string
      hostname: string
      'error-codes'?: string[]
    }

    export async function verifyRecaptchaToken(
      token: string,
      remoteip?: string
    ): Promise<number | null> {
      const secret = process.env.RECAPTCHA_SECRET_KEY
      if (!secret) throw new Error('Missing RECAPTCHA_SECRET_KEY')

      const params = new URLSearchParams({ secret, response: token })
      if (remoteip) params.append('remoteip', remoteip)

      const res = await fetch('https://www.google.com/recaptcha/api/siteverify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: params.toString(),
      })

      const data = (await res.json()) as RecaptchaResponse
      if (!data.success) return null
      return data.score  // 0.0-1.0; higher = more likely human
    }
    ```

    Key details:
    - No npm package needed — native fetch (Node 18+) is sufficient
    - Returns `null` on failure (forged token, network error) or the score on success
    - The caller decides the threshold — keeps this helper reusable
  </action>
  <verify>
    1. `npm ls @upstash/ratelimit` shows installed version
    2. `npm ls libphonenumber-js` shows installed version
    3. `npx tsc --noEmit` passes with no type errors in the two new files
    4. Both files exist: `lib/rate-limit/demo-call.ts` and `lib/recaptcha/verify.ts`
  </verify>
  <done>
    - @upstash/ratelimit and libphonenumber-js installed in package.json
    - lib/rate-limit/demo-call.ts exports ipRatelimit and phoneRatelimit with 10-minute sliding windows and distinct prefixes
    - lib/recaptcha/verify.ts exports verifyRecaptchaToken that POSTs to Google siteverify and returns score or null
    - Both files follow existing project conventions (singleton pattern, error messages, named exports)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create POST /api/demo-call route handler</name>
  <files>
    app/api/demo-call/route.ts
  </files>
  <action>
    Create `app/api/demo-call/route.ts` following the existing pipeline validation pattern from `app/api/pi-intake-audit/capture/route.ts`.

    The route enforces this strict pipeline order:
    1. Parse JSON body
    2. Validate schema with Zod (phone + recaptchaToken required)
    3. Validate phone number as real US number (libphonenumber-js)
    4. Verify reCAPTCHA token server-side (before rate limits to avoid counter poisoning by bots)
    5. Check IP rate limit (Upstash sliding window, 1 per 10 min)
    6. Check phone number rate limit (Upstash sliding window, 1 per 10 min)
    7. Log consent (SEC-05): structured console.log with timestamp, IP, phone, reCAPTCHA score
    8. Create Retell outbound call with `agent_override.agent.max_call_duration_ms: 180_000` (SEC-04)
    9. Return success response

    **Implementation details:**

    Zod schema:
    ```typescript
    const bodySchema = z.object({
      phone: z.string().min(1),
      recaptchaToken: z.string().min(1),
    })
    ```

    Phone validation using libphonenumber-js:
    ```typescript
    import { parsePhoneNumberFromString } from 'libphonenumber-js'

    const parsedPhone = parsePhoneNumberFromString(phone, 'US')
    if (!parsedPhone || !parsedPhone.isValid() || parsedPhone.country !== 'US') {
      return NextResponse.json({ success: false, error: 'Please enter a valid US phone number.' }, { status: 400 })
    }
    const e164Phone = parsedPhone.format('E.164')
    ```

    reCAPTCHA threshold: Use 0.3 (low-stakes public demo form; Google default is 0.5 but 0.3 reduces false rejections for legitimate mobile users).

    Client IP extraction:
    ```typescript
    function getClientIp(request: NextRequest): string {
      return (
        request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ??
        request.headers.get('x-real-ip') ??
        '127.0.0.1'
      )
    }
    ```

    Rate limit 429 responses — include `retryAfter` field (seconds until reset) for Phase 4 UX-05 compatibility:
    ```typescript
    const retryAfter = Math.ceil((ipResult.reset - Date.now()) / 1000)
    return NextResponse.json(
      { success: false, error: 'Too many requests from your location. Try again in 10 minutes.', retryAfter },
      { status: 429 }
    )
    ```

    Consent log format (SEC-05):
    ```typescript
    console.log('[Demo Call] Consent logged:', JSON.stringify({
      timestamp: new Date().toISOString(),
      ip: clientIp,
      phone: e164Phone,
      recaptchaScore: score,
    }))
    ```

    Retell call creation (SEC-01, SEC-04):
    ```typescript
    await retell.call.createPhoneCall({
      from_number: process.env.RETELL_PHONE_NUMBER!,
      to_number: e164Phone,
      agent_override: {
        agent: {
          max_call_duration_ms: 180_000,
        },
      },
    })
    ```

    CRITICAL — Do NOT set max_call_duration_ms on the agent object (causes version mismatch). Always use agent_override at the per-call level (per STATE.md decision from Phase 1).

    Response shape for all paths (designed for Phase 4 UI consumption):
    - 200: `{ success: true }`
    - 400: `{ success: false, error: string }` (validation failures)
    - 401: `{ success: false, error: string }` (reCAPTCHA failure)
    - 429: `{ success: false, error: string, retryAfter: number }` (rate limit)
    - 500: `{ success: false, error: string }` (unexpected errors)

    Error handling: Wrap entire handler in try-catch, log with `[Demo Call]` prefix (matching project convention).

    SEC-01 enforcement: The route file imports `retell` from `@/lib/retell/client` which has a server-only guard (throws if RETELL_API_KEY missing at import time). Since this is an App Router route handler (server-only by definition), the API key never reaches the client bundle.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with no type errors
    2. `npm run lint` passes
    3. File exists at `app/api/demo-call/route.ts` and exports a POST function
    4. Route imports from all three helper modules: `@/lib/retell/client`, `@/lib/rate-limit/demo-call`, `@/lib/recaptcha/verify`
    5. The string `max_call_duration_ms: 180_000` appears in the file (SEC-04)
    6. A `console.log` with `[Demo Call] Consent logged:` appears in the file (SEC-05)
    7. The string `agent_override` appears in the createPhoneCall call (per-call duration, not agent-level)
  </verify>
  <done>
    - app/api/demo-call/route.ts exports POST function implementing the full security pipeline
    - Pipeline order: parse JSON -> Zod validate -> US phone validate -> reCAPTCHA verify -> IP rate limit -> phone rate limit -> consent log -> Retell call
    - Non-US phone returns 400; forged reCAPTCHA returns 401; rate limit violations return 429 with retryAfter; unexpected errors return 500
    - Call duration capped at 180 seconds via agent_override.agent.max_call_duration_ms (not agent-level)
    - Consent logged as structured JSON to stdout with timestamp, IP, phone, reCAPTCHA score
    - TypeScript compiles cleanly and lint passes
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all new files type-check without errors
2. `npm run lint` — no lint violations
3. `npm run build` — production build succeeds (confirms no server-only code leaks to client bundle)
4. Verify file count: 3 new files created (lib/rate-limit/demo-call.ts, lib/recaptcha/verify.ts, app/api/demo-call/route.ts)
5. Verify imports: route.ts imports from all three helper modules
6. Verify SEC-04: `180_000` appears in route.ts within an `agent_override` block
7. Verify SEC-05: `Consent logged` appears in route.ts
</verification>

<success_criteria>
- All five SEC requirements have corresponding code in the route handler
- The route compiles, lints, and builds without errors
- Helper modules follow existing project patterns (singleton, named exports, error messages)
- The security pipeline executes in the correct order (reCAPTCHA before rate limits to prevent counter poisoning)
- Response shapes are consistent and designed for Phase 4 UI consumption
</success_criteria>

<output>
After completion, create `.planning/phases/02-secure-api-route/02-01-SUMMARY.md`
</output>
